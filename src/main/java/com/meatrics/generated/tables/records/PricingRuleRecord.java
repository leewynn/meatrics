/*
 * This file is generated by jOOQ.
 */
package com.meatrics.generated.tables.records;


import com.meatrics.generated.tables.PricingRule;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;

import org.jooq.Record1;
import org.jooq.impl.UpdatableRecordImpl;


/**
 * Dynamic pricing rules for calculating sell prices based on conditions
 */
@SuppressWarnings({ "all", "unchecked", "rawtypes", "this-escape" })
public class PricingRuleRecord extends UpdatableRecordImpl<PricingRuleRecord> {

    private static final long serialVersionUID = 1L;

    /**
     * Setter for <code>public.pricing_rule.id</code>.
     */
    public void setId(Long value) {
        set(0, value);
    }

    /**
     * Getter for <code>public.pricing_rule.id</code>.
     */
    public Long getId() {
        return (Long) get(0);
    }

    /**
     * Setter for <code>public.pricing_rule.rule_name</code>. User-friendly name
     * for the rule (e.g., "ABC Meats - Beef Premium")
     */
    public void setRuleName(String value) {
        set(1, value);
    }

    /**
     * Getter for <code>public.pricing_rule.rule_name</code>. User-friendly name
     * for the rule (e.g., "ABC Meats - Beef Premium")
     */
    public String getRuleName() {
        return (String) get(1);
    }

    /**
     * Setter for <code>public.pricing_rule.customer_code</code>. NULL for
     * standard rules, customer code for customer-specific rules
     */
    public void setCustomerCode(String value) {
        set(2, value);
    }

    /**
     * Getter for <code>public.pricing_rule.customer_code</code>. NULL for
     * standard rules, customer code for customer-specific rules
     */
    public String getCustomerCode() {
        return (String) get(2);
    }

    /**
     * Setter for <code>public.pricing_rule.condition_type</code>. Type of
     * condition: ALL_PRODUCTS, CATEGORY, PRODUCT_CODE
     */
    public void setConditionType(String value) {
        set(3, value);
    }

    /**
     * Getter for <code>public.pricing_rule.condition_type</code>. Type of
     * condition: ALL_PRODUCTS, CATEGORY, PRODUCT_CODE
     */
    public String getConditionType() {
        return (String) get(3);
    }

    /**
     * Setter for <code>public.pricing_rule.condition_value</code>. Value to
     * match against (e.g., "BEEF" for category, NULL for ALL_PRODUCTS)
     */
    public void setConditionValue(String value) {
        set(4, value);
    }

    /**
     * Getter for <code>public.pricing_rule.condition_value</code>. Value to
     * match against (e.g., "BEEF" for category, NULL for ALL_PRODUCTS)
     */
    public String getConditionValue() {
        return (String) get(4);
    }

    /**
     * Setter for <code>public.pricing_rule.pricing_method</code>. Pricing
     * calculation method: COST_PLUS_PERCENT, COST_PLUS_FIXED, FIXED_PRICE
     */
    public void setPricingMethod(String value) {
        set(5, value);
    }

    /**
     * Getter for <code>public.pricing_rule.pricing_method</code>. Pricing
     * calculation method: COST_PLUS_PERCENT, COST_PLUS_FIXED, FIXED_PRICE
     */
    public String getPricingMethod() {
        return (String) get(5);
    }

    /**
     * Setter for <code>public.pricing_rule.pricing_value</code>. Value for
     * calculation (e.g., 1.20 for 20% markup, 5.00 for $5 markup). Can be NULL
     * for MAINTAIN_GP_PERCENT (uses historical GP% only)
     */
    public void setPricingValue(BigDecimal value) {
        set(6, value);
    }

    /**
     * Getter for <code>public.pricing_rule.pricing_value</code>. Value for
     * calculation (e.g., 1.20 for 20% markup, 5.00 for $5 markup). Can be NULL
     * for MAINTAIN_GP_PERCENT (uses historical GP% only)
     */
    public BigDecimal getPricingValue() {
        return (BigDecimal) get(6);
    }

    /**
     * Setter for <code>public.pricing_rule.priority</code>. Lower number =
     * higher priority. First matching rule wins.
     */
    public void setPriority(Integer value) {
        set(7, value);
    }

    /**
     * Getter for <code>public.pricing_rule.priority</code>. Lower number =
     * higher priority. First matching rule wins.
     */
    public Integer getPriority() {
        return (Integer) get(7);
    }

    /**
     * Setter for <code>public.pricing_rule.is_active</code>. Whether this rule
     * is currently active
     */
    public void setIsActive(Boolean value) {
        set(8, value);
    }

    /**
     * Getter for <code>public.pricing_rule.is_active</code>. Whether this rule
     * is currently active
     */
    public Boolean getIsActive() {
        return (Boolean) get(8);
    }

    /**
     * Setter for <code>public.pricing_rule.created_at</code>.
     */
    public void setCreatedAt(LocalDateTime value) {
        set(9, value);
    }

    /**
     * Getter for <code>public.pricing_rule.created_at</code>.
     */
    public LocalDateTime getCreatedAt() {
        return (LocalDateTime) get(9);
    }

    /**
     * Setter for <code>public.pricing_rule.updated_at</code>.
     */
    public void setUpdatedAt(LocalDateTime value) {
        set(10, value);
    }

    /**
     * Getter for <code>public.pricing_rule.updated_at</code>.
     */
    public LocalDateTime getUpdatedAt() {
        return (LocalDateTime) get(10);
    }

    /**
     * Setter for <code>public.pricing_rule.rule_category</code>. Category/layer
     * of the pricing rule: BASE_PRICE (foundation layer), CUSTOMER_ADJUSTMENT
     * (customer-specific modifications), PRODUCT_ADJUSTMENT (product-specific
     * adjustments), PROMOTIONAL (time-bound promotions)
     */
    public void setRuleCategory(String value) {
        set(11, value);
    }

    /**
     * Getter for <code>public.pricing_rule.rule_category</code>. Category/layer
     * of the pricing rule: BASE_PRICE (foundation layer), CUSTOMER_ADJUSTMENT
     * (customer-specific modifications), PRODUCT_ADJUSTMENT (product-specific
     * adjustments), PROMOTIONAL (time-bound promotions)
     */
    public String getRuleCategory() {
        return (String) get(11);
    }

    /**
     * Setter for <code>public.pricing_rule.layer_order</code>. Execution order
     * within the same rule_category. Lower number executes first. Used for
     * fine-grained control when multiple rules in the same layer apply.
     */
    public void setLayerOrder(Integer value) {
        set(12, value);
    }

    /**
     * Getter for <code>public.pricing_rule.layer_order</code>. Execution order
     * within the same rule_category. Lower number executes first. Used for
     * fine-grained control when multiple rules in the same layer apply.
     */
    public Integer getLayerOrder() {
        return (Integer) get(12);
    }

    /**
     * Setter for <code>public.pricing_rule.valid_from</code>. Date when this
     * rule becomes active. NULL means the rule is always active (no start date
     * restriction). Used for scheduling price changes and promotions.
     */
    public void setValidFrom(LocalDate value) {
        set(13, value);
    }

    /**
     * Getter for <code>public.pricing_rule.valid_from</code>. Date when this
     * rule becomes active. NULL means the rule is always active (no start date
     * restriction). Used for scheduling price changes and promotions.
     */
    public LocalDate getValidFrom() {
        return (LocalDate) get(13);
    }

    /**
     * Setter for <code>public.pricing_rule.valid_to</code>. Date when this rule
     * expires. NULL means the rule never expires (no end date restriction).
     * Used for time-bound promotions and seasonal pricing.
     */
    public void setValidTo(LocalDate value) {
        set(14, value);
    }

    /**
     * Getter for <code>public.pricing_rule.valid_to</code>. Date when this rule
     * expires. NULL means the rule never expires (no end date restriction).
     * Used for time-bound promotions and seasonal pricing.
     */
    public LocalDate getValidTo() {
        return (LocalDate) get(14);
    }

    // -------------------------------------------------------------------------
    // Primary key information
    // -------------------------------------------------------------------------

    @Override
    public Record1<Long> key() {
        return (Record1) super.key();
    }

    // -------------------------------------------------------------------------
    // Constructors
    // -------------------------------------------------------------------------

    /**
     * Create a detached PricingRuleRecord
     */
    public PricingRuleRecord() {
        super(PricingRule.PRICING_RULE);
    }

    /**
     * Create a detached, initialised PricingRuleRecord
     */
    public PricingRuleRecord(Long id, String ruleName, String customerCode, String conditionType, String conditionValue, String pricingMethod, BigDecimal pricingValue, Integer priority, Boolean isActive, LocalDateTime createdAt, LocalDateTime updatedAt, String ruleCategory, Integer layerOrder, LocalDate validFrom, LocalDate validTo) {
        super(PricingRule.PRICING_RULE);

        setId(id);
        setRuleName(ruleName);
        setCustomerCode(customerCode);
        setConditionType(conditionType);
        setConditionValue(conditionValue);
        setPricingMethod(pricingMethod);
        setPricingValue(pricingValue);
        setPriority(priority);
        setIsActive(isActive);
        setCreatedAt(createdAt);
        setUpdatedAt(updatedAt);
        setRuleCategory(ruleCategory);
        setLayerOrder(layerOrder);
        setValidFrom(validFrom);
        setValidTo(validTo);
        resetTouchedOnNotNull();
    }
}
